threading
python gil(global interpreter lock)
	gil使得同一时刻只有一个线程在一个CPU上执行字节码，无法将多个线程映射到多CPU
	gil会根据执行的字节码行数以及时间片释放gill，gill在遇到io操作的时候主动释放
对于io操作来说，多线程和多进程的差别并不大，threading.join()是实现在线程执行完之后才执行之后的mainthreading操作；setDaemon()启动守护线程，mainthreading执行完之后便不再执行之后的操作
在代码量比较多的情况下通过类继承threading来实现编译
线程的通信方式：共享变量（安全性问题）
			 queue方式进行线程间同步，无安全性问题
			 queue的相关操作(put将数据写入队列，get从queue提取数据，qsize获取队列长度，empty判断队列是否为空，full判断队列是否已满，如果已满，put会阻塞，put默认block为true，这时可以设置一个timeout值，如果到达timeout时，队列就不会等待了，join阻塞队列，在执行tesk_done时才会退出阻塞状态)
线程同步问题：from threading import lock（必须acquire和release），这样导致的问题：运行时间比较慢，影响性能；容易引起死锁
			解决死锁问题（RLock，在同一个线程里面可以多次调用多次acquire，一定注意acquire的次数必须和release次数相同）
条件变量，用于复杂的线程间同步（from threading import Condition）
		wait：等待某个notify通知
		notify：通知wait
		condition中线程的启动顺序很重要，必须先调用wait线程
		在调用with之后才能调用wait方法或者notify方法
		condition有两层锁，一把底层锁会在线程调用了wait方法的时候释放，上面的锁会在每次调用wait的时候分配一把并放入到cond的等待队列中，等待notify方法的唤醒
可以通过semaphore限制多线程启动的数量（threading.Semaphore）
线程池（from concurrent.futures import ThreadPoolExecutor,as_completed,wait）：
		as_comlpeted是一个生成器
		wait(task)---等待task执行完成再执行后续操作，还可以执行执行了几个task之后再执行下面操作
	为什么要线程池：
	1.主线程中可以获取某一个线程的状态或者某一个任务的状态，以及返回值
	2.当一个线程完成的时候我们主线程立即知道
	3.futures可以让多线程和多进程编程接口一致
	excutor = ThreadPoolExcutor(max_workers=2)-----线程池同时运行大小
	task=excutor.submit(target,args)----通过submit函数提交执行的函数到线程池中
										submit是立即返回
	task.done()---判断是否执行成功
	task.result()----获取task的执行结果
	task.cancel()--- 取消task执行
	excutor.map(target,args) ---通过excutor获取已经完成的task
	from concurrent.futures import Future
	一般将Future定义为未来对象，指的是当前还没完成，有可能在未来完成的task


os.fork()----只适用于Linux/Unix，生成一个子进程，子进程会复制一份父进程数据，再重新执行
			 一次父进程的流程，加了sleep之后，父进程会等待子进程完成之后再退出
from concurrent.futures import ProcessPoolExcutor---多进程编程
import multiprocessing ---多进程编程，与多线程不同的多一个pid
使用进程池
pool = multiprocessing.Pool(进程个数) 默认为CPU个数--multiprocessing.cpu_count()
result = pool.apply_async(target,args)--异步提交任务
pool.close()
pool.join()---等待所有任务完成
result.get()
pool.imap()和pool.imap_unordered()对应线程池中的map
多进程通信：
	1.from multiprocessing import Queue,与多线程间类似
	2.共享全局变量不适用多进程编程，可以适用于多线程
	3.multiprocessing中的Queue不能用于pool进程池
	4.pool中的进程间通信需要使用manager中的queue（from multiprocessing import Manage）
	5.通过pipe实现进程间通信（from multiprocessing import Pipe）
		pipe只能适用于两个进程间通信
		recevie_pipe,send_pipe = Pipe()
	pipe的性能高于queue
	进程间内存共享：利用Manager函数中的数据类型，可以实现多个进程共享一个数据类型，例:process_dict = Manager().dict()

python一切皆对象
	函数和类也是对象：1.赋值给一个变量
					2.可以添加到集合对象中
					3.可以作为参数传递给函数
					4.可以当做函数的返回值
	type,object和class的关系:类是由type生成的一个对象
							object是最顶层的基类，是所有类型的基类，包括type，type是所有对象的实例，包括type自身和object
	None对象全局只有一个（id(None) == id(None)）
抽象基类:
	是通过继承的关系来限制子类必须做的一些操作，利用abc模块中来生成一个装饰器，可以实现对子类的必须操作

type和isinstance的区别:
	type的本质是判断两种类型的ID是否相等,比如 type(a) is A,而继承链的关系则没法通过这样来判断，isinstance是通过继承关系来判断的，而不用通过ID来比较

类变量与实例变量:
	实例就是类赋予的变量，类变量是位于构造函数之上的值，在检查实例变量时，默认会先检查构造函数的值，如果构造函数中不存在，会继续往上查找，还是不存在才会抛出异常，在外面修改类变量的值时，python会默认生成一个不存在的变量值，这个可以通过ID值查看，这导致了修改实例变量得到的值优先于类变量

多重继承查找顺序:默认查找顺序放在__mro__魔法函数中
Python的自省机制：通过一定的机制查询到对象的内部结构，可以通过__dict__来查询到对象内部的结构，以key，value的形式显示；还可以使用dir函数来查看对象内部的结构
super函数的查找顺序：super函数的默认查找顺序是按照mro顺序查找，在使用多继承的时候，想要规定super中父类的运行顺序，必须按照mro规定排序
上下文管理器：1.with语句实现上下文管理：利用魔法函数__enter__(获取资源)和__exit__(释放资源)来规划类中的运行顺序
		    2.利用contextlib中的contextlib.contextmanager生成一个装饰器，以yield来作为运行顺序的分界点